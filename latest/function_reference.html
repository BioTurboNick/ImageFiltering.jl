<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function reference · ImageFiltering</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>ImageFiltering</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">ImageFiltering.jl</a></li><li class="current"><a class="toctext" href="function_reference.html">Function reference</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Kernel-1">Kernel</a></li><li class="toplevel"><a class="toctext" href="#KernelFactors-1">KernelFactors</a></li><li class="toplevel"><a class="toctext" href="#Kernel-utilities-1">Kernel utilities</a></li><li class="toplevel"><a class="toctext" href="#Boundaries-and-padding-1">Boundaries and padding</a></li><li class="toplevel"><a class="toctext" href="#Algorithms-1">Algorithms</a></li><li class="toplevel"><a class="toctext" href="#Internal-machinery-1">Internal machinery</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="function_reference.html">Function reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/docs/src/function_reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Filtering-functions-1" href="#Filtering-functions-1">Filtering functions</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.imfilter" href="#ImageFiltering.imfilter"><code>ImageFiltering.imfilter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imfilter([T], img, kernel, [border=&quot;replicate&quot;], [alg]) --&gt; imgfilt
imfilter([r], img, kernel, [border=&quot;replicate&quot;], [alg]) --&gt; imgfilt
imfilter(r, T, img, kernel, [border=&quot;replicate&quot;], [alg]) --&gt; imgfilt</code></pre><p>Filter an array <code>img</code> with kernel <code>kernel</code> by computing their correlation.</p><p><code>kernel[0,0,..]</code> corresponds to the origin (zero displacement) of the kernel; you can use <code>centered</code> to place the origin at the array center, or use the OffsetArrays package to set <code>kernel</code>&#39;s indices manually. For example, to filter with a random <em>centered</em> 3x3 kernel, you could use either of the following:</p><pre><code class="language-none">kernel = centered(rand(3,3))
kernel = OffsetArray(rand(3,3), -1:1, -1:1)</code></pre><p><code>kernel</code> can be specified as an array or as a &quot;factored kernel,&quot; a tuple <code>(filt1, filt2, ...)</code> of filters to apply along each axis of the image. In cases where you know your kernel is separable, this format can speed processing.  Each of these should have the same dimensionality as the image itself, and be shaped in a manner that indicates the filtering axis, e.g., a 3x1 filter for filtering the first dimension and a 1x3 filter for filtering the second dimension. In two dimensions, any kernel passed as a single matrix is checked for separability; if you want to eliminate that check, pass the kernel as a single-element tuple, <code>(kernel,)</code>.</p><p>Optionally specify the <code>border</code>, as one of <code>Fill(value)</code>, <code>&quot;replicate&quot;</code>, <code>&quot;circular&quot;</code>, <code>&quot;symmetric&quot;</code>, <code>&quot;reflect&quot;</code>, <code>NA()</code>, or <code>Inner()</code>. The default is <code>&quot;replicate&quot;</code>. These choices specify the boundary conditions, and therefore affect the result at the edges of the image. See <code>padarray</code> for more information.</p><p><code>alg</code> allows you to choose the particular algorithm: <code>FIR()</code> (finite impulse response, aka traditional digital filtering) or <code>FFT()</code> (Fourier-based filtering). If no choice is specified, one will be chosen based on the size of the image and kernel in a way that strives to deliver good performance. Alternatively you can use a custom filter type, like <code>KernelFactors.IIRGaussian</code>.</p><p>Optionally, you can control the element type of the output image by passing in a type <code>T</code> as the first argument.</p><p>You can also dispatch to different implementations by passing in a resource <code>r</code> as defined by the ComputationalResources package.  For example,</p><pre><code class="language-none">imfilter(ArrayFire(), img, kernel)</code></pre><p>would request that the computation be performed on the GPU using the ArrayFire libraries.</p><p>See also: <a href="function_reference.html#ImageFiltering.imfilter!"><code>imfilter!</code></a>, <a href="function_reference.html#ImageFiltering.centered"><code>centered</code></a>, <a href="function_reference.html#ImageFiltering.padarray"><code>padarray</code></a>, <a href="function_reference.html#ImageFiltering.Pad"><code>Pad</code></a>, <a href="function_reference.html#ImageFiltering.Fill"><code>Fill</code></a>, <a href="function_reference.html#ImageFiltering.Inner"><code>Inner</code></a>, <a href="function_reference.html#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/imfilter.jl#L50-L104">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.imfilter!" href="#ImageFiltering.imfilter!"><code>ImageFiltering.imfilter!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imfilter!(imgfilt, img, kernel, [border=&quot;replicate&quot;], [alg])
imfilter!(r, imgfilt, img, kernel, border, [inds])
imfilter!(r, imgfilt, img, kernel, border::NoPad, [inds=indices(imgfilt)])</code></pre><p>Filter an array <code>img</code> with kernel <code>kernel</code> by computing their correlation, storing the result in <code>imgfilt</code>.</p><p>The indices of <code>imgfilt</code> determine the region over which the filtered image is computed–-you can use this fact to select just a specific region of interest, although be aware that the input <code>img</code> might still get padded.  Alteratively, explicitly provide the indices <code>inds</code> of <code>imgfilt</code> that you want to calculate, and use <code>NoPad</code> boundary conditions. In such cases, you are responsible for supplying appropriate padding: <code>img</code> must be indexable for all of the locations needed for calculating the output. This syntax is best-supported for FIR filtering; in particular, that that IIR filtering can lead to results that are inconsistent with respect to filtering the entire array.</p><p>See also: <a href="function_reference.html#ImageFiltering.imfilter"><code>imfilter</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/imfilter.jl#L146-L167">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.imgradients" href="#ImageFiltering.imgradients"><code>ImageFiltering.imgradients</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">imgradients(img, kernelfun=KernelFactors.ando3, border=&quot;replicate&quot;) -&gt; gimg1, gimg2, ...</code></pre><p>Estimate the gradient of <code>img</code> at all points of the image, using a kernel specified by <code>kernelfun</code>. The gradient is returned as a tuple-of-arrays, one for each dimension of the input; <code>gimg1</code> corresponds to the derivative with respect to the first dimension, <code>gimg2</code> to the second, and so on. At the image edges, <code>border</code> is used to specify the boundary conditions.</p><p><code>kernelfun</code> may be one of the filters defined in the <code>KernelFactors</code> module, or more generally any function which satisfies the following interface:</p><pre><code class="language-none">kernelfun(extended::NTuple{N,Bool}, d) -&gt; kern_d</code></pre><p><code>kern_d</code> is the kernel for producing the derivative with respect to the <code>d</code>th dimension of an <code>N</code>-dimensional array. <code>extended[i]</code> is true if the image is of size &gt; 1 along dimension <code>i</code>. <code>kern_d</code> may be provided as a dense or factored kernel, with factored representations recommended when the kernel is separable.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/specialty.jl#L19-L40">source</a><br/><div><pre><code class="language-none">imgradients(img, points, [kernelfunc], [border]) -&gt; G</code></pre><p>Performs edge detection filtering in the N-dimensional array <code>img</code>. Gradients are computed at specified <code>points</code> (or indexes) in the array.</p><p>All kernel functions are specified as <code>KernelFactors.func</code>. For 2d images, the choices for <code>func</code> include <code>sobel</code>, <code>prewitt</code>, <code>ando3</code>, <code>ando4</code>, and <code>ando5</code>. For other dimensionalities, the <code>ando4</code> and <code>ando5</code> kernels are not available.</p><p>Border options:<code>&quot;replicate&quot;</code>, <code>&quot;circular&quot;</code>, <code>&quot;reflect&quot;</code>, <code>&quot;symmetric&quot;</code>.</p><p>Returns a 2D array <code>G</code> with the gradients as rows. The number of rows is the number of points at which the gradient was computed and the number of columns is the dimensionality of the array.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/specialty.jl#L66-L83">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.MapWindow.mapwindow" href="#ImageFiltering.MapWindow.mapwindow"><code>ImageFiltering.MapWindow.mapwindow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mapwindow(f, img, window, [border=&quot;replicate&quot;]) -&gt; imgf</code></pre><p>Apply <code>f</code> to sliding windows of <code>img</code>, with window size or indices specified by <code>window</code>. For example, <code>mapwindow(median!, img, window)</code> returns an <code>Array</code> of values similar to <code>img</code> (median-filtered, of course), whereas <code>mapwindow(extrema, img, window)</code> returns an <code>Array</code> of <code>(min,max)</code> tuples over a window of size <code>window</code> centered on each point of <code>img</code>.</p><p>The function <code>f</code> receives a buffer <code>buf</code> for the window of data surrounding the current point. If <code>window</code> is specified as a Dims-tuple (tuple-of-integers), then all the integers must be odd and the window is centered around the current image point. For example, if <code>window=(3,3)</code>, then <code>f</code> will receive an Array <code>buf</code> corresponding to offsets <code>(-1:1, -1:1)</code> from the <code>imgf[i,j]</code> for which this is currently being computed. Alternatively, <code>window</code> can be a tuple of AbstractUnitRanges, in which case the specified ranges are used for <code>buf</code>; this allows you to use asymmetric windows if needed.</p><p><code>border</code> specifies how the edges of <code>img</code> should be handled; see <code>imfilter</code> for details.</p><p>For functions that can only take <code>AbstractVector</code> inputs, you might have to first specialize <code>default_shape</code>:</p><pre><code class="language-julia">f = v-&gt;quantile(v, 0.75)
ImageFiltering.MapWindow.default_shape(::typeof(f)) = vec</code></pre><p>and then <code>mapwindow(f, img, (m,n))</code> should filter at the 75th quantile.</p><p>See also: <a href="function_reference.html#ImageFiltering.imfilter"><code>imfilter</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/mapwindow.jl#L9-L43">source</a><br/></section><h1><a class="nav-anchor" id="Kernel-1" href="#Kernel-1">Kernel</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.sobel" href="#ImageFiltering.Kernel.sobel"><code>ImageFiltering.Kernel.sobel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = sobel()</code></pre><p>Return kernels for two-dimensional gradient compution using the Sobel operator. <code>diff1</code> computes the gradient along the first (y) dimension, and <code>diff2</code> computes the gradient along the second (x) dimension.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.sobel"><code>KernelFactors.sobel</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.prewitt"><code>Kernel.prewitt</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L12-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.prewitt" href="#ImageFiltering.Kernel.prewitt"><code>ImageFiltering.Kernel.prewitt</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = prewitt()</code></pre><p>Return kernels for two-dimensional gradient compution using the Prewitt operator.  <code>diff1</code> computes the gradient along the first (y) dimension, and <code>diff2</code> computes the gradient along the second (x) dimension.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.prewitt"><code>KernelFactors.prewitt</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.sobel"><code>Kernel.sobel</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L25-L34">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.ando3" href="#ImageFiltering.Kernel.ando3"><code>ImageFiltering.Kernel.ando3</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = ando3()</code></pre><p>Return 3x3 kernels for two-dimensional gradient compution using the optimal &quot;Ando&quot; filters.  <code>diff1</code> computes the gradient along the y-axis (first dimension), and <code>diff2</code> computes the gradient along the x-axis (second dimension).</p><p><strong>Citation</strong></p><p>Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.ando3"><code>KernelFactors.ando3</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando4"><code>Kernel.ando4</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando5"><code>Kernel.ando5</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L39-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.ando4" href="#ImageFiltering.Kernel.ando4"><code>ImageFiltering.Kernel.ando4</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = ando4()</code></pre><p>Return 4x4 kernels for two-dimensional gradient compution using the optimal &quot;Ando&quot; filters.  <code>diff1</code> computes the gradient along the y-axis (first dimension), and <code>diff2</code> computes the gradient along the x-axis (second dimension).</p><p><strong>Citation</strong></p><p>Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.ando4"><code>KernelFactors.ando4</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando5"><code>Kernel.ando5</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L57-L70">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.ando5" href="#ImageFiltering.Kernel.ando5"><code>ImageFiltering.Kernel.ando5</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">diff1, diff2 = ando5()</code></pre><p>Return 5x5 kernels for two-dimensional gradient compution using the optimal &quot;Ando&quot; filters.  <code>diff1</code> computes the gradient along the y-axis (first dimension), and <code>diff2</code> computes the gradient along the x-axis (second dimension).</p><p><strong>Citation</strong></p><p>Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.ando5"><code>KernelFactors.ando5</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando3"><code>Kernel.ando3</code></a>, <a href="function_reference.html#ImageFiltering.Kernel.ando4"><code>Kernel.ando4</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L84-L97">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.gaussian" href="#ImageFiltering.Kernel.gaussian"><code>ImageFiltering.Kernel.gaussian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gaussian((σ1, σ2, ...), [(l1, l2, ...]) -&gt; g
gaussian(σ)                  -&gt; g</code></pre><p>Construct a multidimensional gaussian filter, with standard deviation <code>σd</code> along dimension <code>d</code>. Optionally provide the kernel length <code>l</code>, which must be a tuple of the same length.</p><p>If <code>σ</code> is supplied as a single number, a symmetric 2d kernel is constructed.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.gaussian"><code>KernelFactors.gaussian</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L112-L124">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.DoG" href="#ImageFiltering.Kernel.DoG"><code>ImageFiltering.Kernel.DoG</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">DoG((σp1, σp2, ...), (σm1, σm2, ...), [l1, l2, ...]) -&gt; k
DoG((σ1, σ2, ...))                                   -&gt; k
DoG(σ::Real)                                         -&gt; k</code></pre><p>Construct a multidimensional difference-of-gaussian kernel <code>k</code>, equal to <code>gaussian(σp, l)-gaussian(σm, l)</code>.  When only a single <code>σ</code> is supplied, the default is to choose <code>σp = σ, σm = √2 σ</code>. Optionally provide the kernel length <code>l</code>; the default is to extend by two <code>max(σp,σm)</code> in each direction from the center. <code>l</code> must be odd.</p><p>If <code>σ</code> is provided as a single number, a symmetric 2d DoG kernel is returned.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L139-L154">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.LoG" href="#ImageFiltering.Kernel.LoG"><code>ImageFiltering.Kernel.LoG</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">LoG((σ1, σ2, ...)) -&gt; k
LoG(σ)             -&gt; k</code></pre><p>Construct a Laplacian-of-Gaussian kernel <code>k</code>. <code>σd</code> is the gaussian width along dimension <code>d</code>.  If <code>σ</code> is supplied as a single number, a symmetric 2d kernel is returned.</p><p>See also: <a href="function_reference.html#ImageFiltering.KernelFactors.IIRGaussian"><code>KernelFactors.IIRGaussian</code></a> and <a href="function_reference.html#ImageFiltering.Kernel.Laplacian"><code>Kernel.Laplacian</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L165-L174">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.Laplacian" href="#ImageFiltering.Kernel.Laplacian"><code>ImageFiltering.Kernel.Laplacian</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Laplacian((true,true,false,...))
Laplacian(dims, N)
Lacplacian()</code></pre><p>Laplacian kernel in <code>N</code> dimensions, taking derivatives along the directions marked as <code>true</code> in the supplied tuple. Alternatively, one can pass <code>dims</code>, a listing of the dimensions for differentiation. (However, this variant is not inferrable.)</p><p><code>Laplacian()</code> is the 2d laplacian, equivalent to <code>Laplacian((true,true))</code>.</p><p>The kernel is represented as an opaque type, but you can use <code>convert(AbstractArray, L)</code> to convert it into array format.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L207-L221">source</a><br/></section><h1><a class="nav-anchor" id="KernelFactors-1" href="#KernelFactors-1">KernelFactors</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.sobel" href="#ImageFiltering.KernelFactors.sobel"><code>ImageFiltering.KernelFactors.sobel</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">kern1, kern2 = sobel()</code></pre><p>Factored Sobel filters for dimensions 1 and 2 of a two-dimensional image. Each is a 2-tuple of one-dimensional filters.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L131-L136">source</a><br/><div><pre><code class="language-none">kern = sobel(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Sobel filter for computing the gradient in <code>N</code> dimensions along axis <code>d</code>. If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L143-L148">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.prewitt" href="#ImageFiltering.KernelFactors.prewitt"><code>ImageFiltering.KernelFactors.prewitt</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>kern1, kern2 = prewitt()</code> returns factored Prewitt filters for dimensions 1 and 2 of your image</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L153">source</a><br/><div><pre><code class="language-none">kern = prewitt(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Prewitt filter for computing the gradient in <code>N</code> dimensions along axis <code>d</code>. If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L160-L165">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.ando3" href="#ImageFiltering.KernelFactors.ando3"><code>ImageFiltering.KernelFactors.ando3</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>kern1, kern2 = ando3()</code> returns optimal 3x3 gradient filters for dimensions 1 and 2 of your image, as defined in Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000.</p><p>See also: <a href="@ref"><code>Kernel.ando3</code></a>, <a href="function_reference.html#ImageFiltering.KernelFactors.ando4"><code>KernelFactors.ando4</code></a>, <a href="function_reference.html#ImageFiltering.KernelFactors.ando5"><code>KernelFactors.ando5</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L179-L184">source</a><br/><div><pre><code class="language-none">kern = ando3(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Ando filter (size 3) for computing the gradient in <code>N</code> dimensions along axis <code>d</code>.  If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L191-L197">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.ando4" href="#ImageFiltering.KernelFactors.ando4"><code>ImageFiltering.KernelFactors.ando4</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>kern1, kern2 = ando4()</code> returns separable approximations of the optimal 4x4 filters for dimensions 1 and 2 of your image, as defined in Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000.</p><p>See also: <a href="@ref"><code>Kernel.ando4</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L202-L209">source</a><br/><div><pre><code class="language-none">kern = ando4(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Ando filter (size 4) for computing the gradient in <code>N</code> dimensions along axis <code>d</code>.  If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L216-L222">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.ando5" href="#ImageFiltering.KernelFactors.ando5"><code>ImageFiltering.KernelFactors.ando5</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>kern1, kern2 = ando5_sep()</code> returns separable approximations of the optimal 5x5 gradient filters for dimensions 1 and 2 of your image, as defined in Ando Shigeru, IEEE Trans. Pat. Anal. Mach. Int., vol. 22 no 3, March 2000.</p><p>See also: <a href="@ref"><code>Kernel.ando5</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L231-L238">source</a><br/><div><pre><code class="language-none">kern = ando5(extended::NTuple{N,Bool}, d)</code></pre><p>Return a factored Ando filter (size 5) for computing the gradient in <code>N</code> dimensions along axis <code>d</code>.  If <code>extended[dim]</code> is false, <code>kern</code> will have size 1 along that dimension.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L245-L251">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.gaussian" href="#ImageFiltering.KernelFactors.gaussian"><code>ImageFiltering.KernelFactors.gaussian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gaussian(σ::Real, [l]) -&gt; g</code></pre><p>Construct a 1d gaussian kernel <code>g</code> with standard deviation <code>σ</code>, optionally providing the kernel length <code>l</code>. The default is to extend by two <code>σ</code> in each direction from the center. <code>l</code> must be odd.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L262-L268">source</a><br/><div><pre><code class="language-none">gaussian((σ1, σ2, ...), [l]) -&gt; (g1, g2, ...)</code></pre><p>Construct a multidimensional gaussian filter as a product of single-dimension factors, with standard deviation <code>σd</code> along dimension <code>d</code>. Optionally provide the kernel length <code>l</code>, which must be a tuple of the same length.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L276-L283">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.IIRGaussian" href="#ImageFiltering.KernelFactors.IIRGaussian"><code>ImageFiltering.KernelFactors.IIRGaussian</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">IIRGaussian([T], σ; emit_warning::Bool=true)</code></pre><p>Construct an infinite impulse response (IIR) approximation to a Gaussian of standard deviation <code>σ</code>. <code>σ</code> may either be a single real number or a tuple of numbers; in the latter case, a tuple of such filters will be created, each for filtering a different dimension of an array.</p><p>Optionally specify the type <code>T</code> for the filter coefficients; if not supplied, it will match <code>σ</code> (unless <code>σ</code> is not floating-point, in which case <code>Float64</code> will be chosen).</p><p><strong>Citation</strong></p><p>I. T. Young, L. J. van Vliet, and M. van Ginkel, &quot;Recursive Gabor Filtering&quot;. IEEE Trans. Sig. Proc., 50: 2798-2805 (2002).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L345-L361">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.TriggsSdika" href="#ImageFiltering.KernelFactors.TriggsSdika"><code>ImageFiltering.KernelFactors.TriggsSdika</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">TriggsSdika(a, b, scale, M)</code></pre><p>Defines a kernel for one-dimensional infinite impulse response (IIR) filtering. <code>a</code> is a &quot;forward&quot; filter, <code>b</code> a &quot;backward&quot; filter, <code>M</code> is a matrix for matching boundary conditions at the right edge, and <code>scale</code> is a constant scaling applied to each element at the conclusion of filtering.</p><p><strong>Citation</strong></p><p>B. Triggs and M. Sdika, &quot;Boundary conditions for Young-van Vliet recursive filtering&quot;. IEEE Trans. on Sig. Proc. 54: 2365-2367 (2006).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L303-L317">source</a><br/><div><pre><code class="language-none">TriggsSdika(ab, scale)</code></pre><p>Create a symmetric Triggs-Sdika filter (with <code>a = b = ab</code>). <code>M</code> is calculated for you. Only length 3 filters are currently supported.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L320-L325">source</a><br/></section><h1><a class="nav-anchor" id="Kernel-utilities-1" href="#Kernel-utilities-1">Kernel utilities</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.centered" href="#ImageFiltering.centered"><code>ImageFiltering.centered</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">centered(kernel) -&gt; shiftedkernel</code></pre><p>Shift the origin-of-coordinates to the center of <code>kernel</code>. The center-element of <code>kernel</code> will be accessed by <code>shiftedkernel[0, 0, ...]</code>.</p><p>This function makes it easy to supply kernels using regular Arrays, and provides compatibility with other languages that do not support arbitrary indices.</p><p>See also: <a href="function_reference.html#ImageFiltering.imfilter"><code>imfilter</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/utils.jl#L1-L13">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.kernelfactors" href="#ImageFiltering.KernelFactors.kernelfactors"><code>ImageFiltering.KernelFactors.kernelfactors</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">kernelfactors(factors::Tuple)</code></pre><p>Prepare a factored kernel for filtering. If passed a 2-tuple of vectors of lengths <code>m</code> and <code>n</code>, this will return a 2-tuple of <code>ReshapedVector</code>s that are effectively of sizes <code>m×1</code> and <code>1×n</code>. In general, each successive <code>factor</code> will be reshaped to extend along the corresponding dimension.</p><p>If passed a tuple of general arrays, it is assumed that each is shaped appropriately along its &quot;leading&quot; dimensions; the dimensionality of each is &quot;extended&quot; to <code>N = length(factors)</code>, appending 1s to the size as needed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L402-L414">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Kernel.reflect" href="#ImageFiltering.Kernel.reflect"><code>ImageFiltering.Kernel.reflect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reflect(kernel) --&gt; reflectedkernel</code></pre><p>Compute the pointwise reflection around 0, 0, ... of the kernel <code>kernel</code>.  Using <code>imfilter</code> with a <code>reflectedkernel</code> performs convolution, rather than correlation, with respect to the original <code>kernel</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernel.jl#L243-L249">source</a><br/></section><h1><a class="nav-anchor" id="Boundaries-and-padding-1" href="#Boundaries-and-padding-1">Boundaries and padding</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.padarray" href="#ImageFiltering.padarray"><code>ImageFiltering.padarray</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">padarray([T], img, border) --&gt; imgpadded</code></pre><p>Generate a padded image from an array <code>img</code> and a specification <code>border</code> of the boundary conditions and amount of padding to add. <code>border</code> can be a <code>Pad</code>, <code>Fill</code>, or <code>Inner</code> object.</p><p>Optionally provide the element type <code>T</code> of <code>imgpadded</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/border.jl#L134-L142">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Pad" href="#ImageFiltering.Pad"><code>ImageFiltering.Pad</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>Pad</code> is a type that stores choices about padding. Instances must set <code>style</code>, a Symbol specifying the boundary conditions of the image, one of:</p><ul><li><p><code>:replicate</code> (repeat edge values to infinity)</p></li><li><p><code>:circular</code> (image edges &quot;wrap around&quot;)</p></li><li><p><code>:symmetric</code> (the image reflects relative to a position between pixels)</p></li><li><p><code>:reflect</code> (the image reflects relative to the edge itself)</p></li></ul><p>The default value is <code>:replicate</code>.</p><p>It&#39;s worth emphasizing that padding is most straightforwardly specified as a string,</p><pre><code class="language-none">imfilter(img, kernel, &quot;replicate&quot;)</code></pre><p>rather than</p><pre><code class="language-none">imfilter(img, kernel, Pad(:replicate))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/border.jl#L31-L49">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Fill" href="#ImageFiltering.Fill"><code>ImageFiltering.Fill</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Fill(val)
Fill(val, lo, hi)</code></pre><p>Pad the edges of the image with a constant value, <code>val</code>.</p><p>Optionally supply the extent of the padding, see <code>Pad</code>.</p><p><strong>Example:</strong></p><pre><code class="language-none">imfilter(img, kernel, Fill(zero(eltype(img))))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/border.jl#L235-L246">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Inner" href="#ImageFiltering.Inner"><code>ImageFiltering.Inner</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Inner()
Inner(lo, hi)</code></pre><p>Indicate that edges are to be discarded in filtering, only the interior of the result it to be returned.</p><p><strong>Example:</strong></p><pre><code class="language-none">imfilter(img, kernel, Inner())</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/border.jl#L178-L187">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.NA" href="#ImageFiltering.NA"><code>ImageFiltering.NA</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NA()
NA(lo, hi)</code></pre><p>Choose filtering using &quot;NA&quot; (Not Available) boundary conditions. This is most appropriate for filters that have only positive weights, such as blurring filters. Effectively, the output pixel value is normalized in the following way:</p><pre><code class="language-none">          filtered img with Fill(0) boundary conditions
output =  ---------------------------------------------
          filtered 1   with Fill(0) boundary conditions</code></pre><p>As a consequence, filtering has the same behavior as <code>nanmean</code>. Indeed, invalid pixels in <code>img</code> can be marked as <code>NaN</code> and then they are effectively omitted from the filtered result.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/border.jl#L193-L209">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.NoPad" href="#ImageFiltering.NoPad"><code>ImageFiltering.NoPad</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NoPad()
NoPad(border)</code></pre><p>Indicates that no padding should be applied to the input array, or that you have already pre-padded the input image. Passing a <code>border</code> object allows you to preserve &quot;memory&quot; of a border choice; it can be retrieved by indexing with <code>[]</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">np = NoPad(Pad(:replicate))
imfilter!(out, img, kernel, np)</code></pre><p>runs filtering directly, skipping any padding steps.  Every entry of <code>out</code> must be computable using in-bounds operations on <code>img</code> and <code>kernel</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/border.jl#L12-L26">source</a><br/></section><h1><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Algorithm.FIR" href="#ImageFiltering.Algorithm.FIR"><code>ImageFiltering.Algorithm.FIR</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Filter using a direct algorithm</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/ImageFiltering.jl#L26">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Algorithm.FFT" href="#ImageFiltering.Algorithm.FFT"><code>ImageFiltering.Algorithm.FFT</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Filter using the Fast Fourier Transform</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/ImageFiltering.jl#L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Algorithm.IIR" href="#ImageFiltering.Algorithm.IIR"><code>ImageFiltering.Algorithm.IIR</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Filter with an Infinite Impulse Response filter</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/ImageFiltering.jl#L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.Algorithm.Mixed" href="#ImageFiltering.Algorithm.Mixed"><code>ImageFiltering.Algorithm.Mixed</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Filter with a cascade of mixed types (IIR, FIR)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/ImageFiltering.jl#L31">source</a><br/></section><h1><a class="nav-anchor" id="Internal-machinery-1" href="#Internal-machinery-1">Internal machinery</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageFiltering.KernelFactors.ReshapedOneD" href="#ImageFiltering.KernelFactors.ReshapedOneD"><code>ImageFiltering.KernelFactors.ReshapedOneD</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ReshapedOneD{N,Npre}(data)</code></pre><p>Return an object of dimensionality <code>N</code>, where <code>data</code> must have dimensionality 1. The indices are <code>0:0</code> for the first <code>Npre</code> dimensions, have the indices of <code>data</code> for dimension <code>Npre+1</code>, and are <code>0:0</code> for the remaining dimensions.</p><p><code>data</code> must support <code>eltype</code> and <code>ndims</code>, but does not have to be an AbstractArray.</p><p>ReshapedOneDs allow one to specify a &quot;filtering dimension&quot; for a 1-dimensional filter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaImages/ImageFiltering.jl/tree/0bbf1a3d059955ff0f5c87afce77f858c9ffd2a6/src/kernelfactors.jl#L12-L25">source</a><br/></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">ImageFiltering.jl</span></a></footer></article></body></html>
